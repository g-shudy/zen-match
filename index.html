<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zen Match</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Quicksand', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            overflow: hidden;
        }

        .ambient {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 0;
        }

        .ambient::before,
        .ambient::after {
            content: '';
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.3;
            animation: float 20s ease-in-out infinite;
        }

        .ambient::before {
            background: radial-gradient(circle, #4a90a4 0%, transparent 70%);
            top: 10%;
            left: 10%;
        }

        .ambient::after {
            background: radial-gradient(circle, #8b5a8b 0%, transparent 70%);
            bottom: 10%;
            right: 10%;
            animation-delay: -10s;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            33% { transform: translate(30px, -30px) scale(1.1); }
            66% { transform: translate(-20px, 20px) scale(0.9); }
        }

        .container {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        h1 {
            font-weight: 300;
            font-size: 2rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: #a8c0c8;
            text-shadow: 0 0 30px rgba(168, 192, 200, 0.3);
        }

        .controls-row {
            display: flex;
            gap: 16px;
            align-items: center;
            margin-bottom: 8px;
        }

        .avg-display {
            font-weight: 300;
            font-size: 1rem;
            letter-spacing: 0.15em;
            color: #7a9ea8;
        }

        .gem-slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .gem-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .gem-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #7a9ea8;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }

        .gem-slider::-webkit-slider-thumb:hover {
            background: #95d5b2;
        }

        .gem-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #7a9ea8;
            border: none;
            border-radius: 50%;
            cursor: pointer;
        }

        .gem-slider-value {
            font-size: 0.85rem;
            color: #7a9ea8;
            min-width: 1.5em;
            text-align: center;
        }

        .floating-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(42, 62, 66, 0.95);
            color: #a8c5cf;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .floating-message.visible {
            opacity: 1;
        }

        .avg-display span {
            color: #95d5b2;
            font-weight: 400;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .cell {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.15s ease;
            position: relative;
        }

        .cell:hover {
            transform: scale(1.08);
        }

        .gem {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow:
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
        }

        .gem.selected {
            transform: scale(1.15);
            box-shadow:
                0 0 20px currentColor,
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.3);
            animation: pulse 0.8s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px currentColor, 0 4px 12px rgba(0, 0, 0, 0.3); }
            50% { box-shadow: 0 0 30px currentColor, 0 4px 16px rgba(0, 0, 0, 0.4); }
        }

        .gem.matched {
            animation: vanish 0.3s ease-out forwards;
        }

        @keyframes vanish {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* Explosion animation for bomb gems */
        .gem.exploding {
            animation: explode 0.5s ease-out forwards;
        }

        @keyframes explode {
            0% { transform: scale(1); opacity: 1; }
            30% { transform: scale(1.8); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* Line clear animation */
        .gem.line-cleared {
            animation: lineClear 0.4s ease-out forwards;
        }

        @keyframes lineClear {
            0% { transform: scale(1) scaleX(1); opacity: 1; }
            50% { transform: scale(1.2) scaleX(1.5); opacity: 0.8; }
            100% { transform: scale(0) scaleX(2); opacity: 0; }
        }

        /* Rainbow clear animation */
        .gem.rainbow-cleared {
            animation: rainbowClear 0.5s ease-out forwards;
        }

        @keyframes rainbowClear {
            0% { transform: scale(1) rotate(0deg); opacity: 1; filter: hue-rotate(0deg); }
            50% { transform: scale(1.5) rotate(180deg); opacity: 0.8; filter: hue-rotate(180deg); }
            100% { transform: scale(0) rotate(360deg); opacity: 0; filter: hue-rotate(360deg); }
        }

        .gem.invalid {
            animation: shake 0.4s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
        }

        .gem.falling {
            transition: top 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .gem.swapping {
            transition: all 0.2s ease-in-out;
            z-index: 10;
        }

        /* Gem colors - ordered for maximum adjacent contrast (warm/cool alternating) */
        .gem-0 { background: linear-gradient(135deg, #7ec8e3 0%, #5ba3c0 100%); color: #7ec8e3; } /* blue */
        .gem-1 { background: linear-gradient(135deg, #e07a5f 0%, #c0634b 100%); color: #e07a5f; } /* coral */
        .gem-2 { background: linear-gradient(135deg, #95d5b2 0%, #74b893 100%); color: #95d5b2; } /* green */
        .gem-3 { background: linear-gradient(135deg, #f4d35e 0%, #d4b34e 100%); color: #f4d35e; } /* yellow */
        .gem-4 { background: linear-gradient(135deg, #dda0dd 0%, #b87db8 100%); color: #dda0dd; } /* purple */
        .gem-5 { background: linear-gradient(135deg, #e8a87c 0%, #c38d6e 100%); color: #e8a87c; } /* tan */
        .gem-6 { background: linear-gradient(135deg, #4ecdc4 0%, #3ba89f 100%); color: #4ecdc4; } /* teal */
        .gem-7 { background: linear-gradient(135deg, #ff9f43 0%, #d98436 100%); color: #ff9f43; } /* orange */
        .gem-8 { background: linear-gradient(135deg, #5f6caf 0%, #4a5590 100%); color: #5f6caf; } /* navy */
        .gem-9 { background: linear-gradient(135deg, #ff6b9d 0%, #d9577f 100%); color: #ff6b9d; } /* magenta */

        /* Special gems - BOMB (4-match) - 3x3 explosion */
        .gem.special-bomb {
            border-radius: 50%;
            position: relative;
        }

        .gem.special-bomb::before {
            content: '';
            position: absolute;
            font-size: 18px;
            filter: drop-shadow(0 0 4px rgba(255, 200, 100, 0.8));
            animation: bombPulse 1.5s ease-in-out infinite;
        }

        .gem.special-bomb::after {
            content: '';
            position: absolute;
            inset: -4px;
            border: 2px solid rgba(255, 200, 100, 0.6);
            border-radius: 50%;
            animation: bombRing 1.5s ease-in-out infinite;
        }

        @keyframes bombPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        @keyframes bombRing {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 0.3; }
        }

        /* Special gems - LINE CLEAR (5-match) */
        .gem.special-line {
            border-radius: 8px;
            position: relative;
        }

        .gem.special-line::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
            animation: lineGlow 1s ease-in-out infinite;
        }

        .gem.special-line.horizontal::after {
            width: 100%;
            height: 4px;
        }

        .gem.special-line.vertical::after {
            width: 4px;
            height: 100%;
        }

        .gem.special-line.cross::before,
        .gem.special-line.cross::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
        }

        .gem.special-line.cross::before {
            width: 100%;
            height: 4px;
        }

        .gem.special-line.cross::after {
            width: 4px;
            height: 100%;
        }

        @keyframes lineGlow {
            0%, 100% { opacity: 0.9; box-shadow: 0 0 12px rgba(255, 255, 255, 0.8); }
            50% { opacity: 1; box-shadow: 0 0 20px rgba(255, 255, 255, 1); }
        }

        /* Special gems - RAINBOW (6+ match or L/T shape) */
        .gem.special-rainbow {
            position: relative;
            border-radius: 50%;
            /* Keeps gem-X background color visible in center */
        }

        .gem.special-rainbow::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                #e8a87c, #7ec8e3, #95d5b2, #dda0dd, #f4d35e, #e07a5f, #e8a87c
            );
            /* Mask creates hole in center to show gem's true color */
            -webkit-mask: radial-gradient(circle, transparent 45%, black 55%);
            mask: radial-gradient(circle, transparent 45%, black 55%);
            animation: rainbowSpin 3s linear infinite;
        }

        .gem.special-rainbow::after {
            content: '';
            position: absolute;
            inset: 6px;
            border-radius: 50%;
            background: inherit;
            box-shadow: 0 0 8px currentColor;
        }

        @keyframes rainbowSpin {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        /* Explosion effect overlay */
        .explosion-effect {
            position: absolute;
            pointer-events: none;
            width: 144px; /* 3 cells */
            height: 144px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 200, 100, 0.8) 0%, rgba(255, 100, 50, 0.4) 50%, transparent 70%);
            transform: translate(-50%, -50%) scale(0);
            animation: explosionWave 0.5s ease-out forwards;
            z-index: 50;
        }

        @keyframes explosionWave {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        /* Line effect overlay */
        .line-effect {
            position: absolute;
            pointer-events: none;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
            z-index: 50;
            animation: lineWave 0.4s ease-out forwards;
        }

        .line-effect.horizontal {
            height: 48px;
            width: 100%;
            left: 0;
        }

        .line-effect.vertical {
            width: 48px;
            height: 100%;
            top: 0;
            background: linear-gradient(180deg, transparent, rgba(255, 255, 255, 0.8), transparent);
        }

        @keyframes lineWave {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .cascade-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 1.5rem;
            font-weight: 300;
            color: #f4d35e;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            text-shadow: 0 0 20px rgba(244, 211, 94, 0.5);
        }

        .cascade-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }

        .combo-text {
            position: fixed;
            top: 50px;
            right: 20px;
            font-size: 1.2rem;
            font-weight: 400;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s ease;
        }

        .combo-text.show {
            opacity: 1;
            transform: scale(1);
        }

        .combo-text.good { color: #95d5b2; }
        .combo-text.great { color: #7ec8e3; }
        .combo-text.amazing { color: #dda0dd; }
        .combo-text.incredible { color: #f4d35e; text-shadow: 0 0 15px rgba(244, 211, 94, 0.5); }

        .chain-text {
            position: fixed;
            top: 80px;
            right: 20px;
            font-size: 1rem;
            font-weight: 400;
            color: #e07a5f;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s ease;
            text-shadow: 0 0 10px rgba(224, 122, 95, 0.5);
        }

        .chain-text.show {
            opacity: 1;
            transform: scale(1);
        }

        .score-popup {
            position: absolute;
            pointer-events: none;
            font-size: 1.2rem;
            font-weight: 500;
            color: #f4d35e;
            text-shadow: 0 0 10px rgba(244, 211, 94, 0.5);
            animation: scoreFloat 1s ease-out forwards;
            z-index: 100;
        }

        .score-popup.bonus {
            font-size: 1.5rem;
            color: #dda0dd;
            text-shadow: 0 0 15px rgba(221, 160, 221, 0.5);
        }

        .score-popup.chain {
            font-size: 1.8rem;
            color: #e07a5f;
            text-shadow: 0 0 20px rgba(224, 122, 95, 0.7);
        }

        @keyframes scoreFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
        }

        .hint-text {
            font-size: 0.85rem;
            color: #5a7a84;
            letter-spacing: 0.1em;
            margin-top: 8px;
        }

        .shuffle-notice {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 1.3rem;
            color: #a8c0c8;
            letter-spacing: 0.2em;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 200;
        }

        .shuffle-notice.show {
            opacity: 1;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #5a7a84;
            text-decoration: none;
            font-size: 0.9rem;
            letter-spacing: 0.1em;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: #a8c0c8;
        }

        /* Stats displays */
        .stats-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
            align-items: center;
        }

        .distribution-history {
            display: flex;
            gap: 2px;
            height: 24px;
            align-items: flex-end;
        }

        .dist-bar {
            width: 4px;
            display: flex;
            flex-direction: column-reverse;
            border-radius: 1px;
            overflow: hidden;
        }

        .dist-segment {
            width: 100%;
            transition: height 0.2s ease;
        }

        .avg-sparkline {
            height: 24px;
            opacity: 0.8;
        }

        .score-history {
            display: flex;
            gap: 10px;
            font-size: 0.75rem;
            color: #7a9ea8;
        }

        .score-history span {
            white-space: nowrap;
            opacity: 0.5;
        }

        .score-history span:first-child {
            opacity: 1;
            color: #f4d35e;
        }

        .score-history span.live {
            opacity: 1;
            color: #95d5b2;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }

        .new-game-btn {
            background: rgba(149, 213, 178, 0.2);
            border: 1px solid rgba(149, 213, 178, 0.3);
            color: #95d5b2;
            font-size: 0.85rem;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 0.1em;
        }

        .new-game-btn:hover {
            background: rgba(149, 213, 178, 0.4);
            border-color: rgba(149, 213, 178, 0.6);
            color: #c5f0d6;
        }
    </style>
</head>
<body>
    <div class="ambient"></div>
    <div class="container">
        <h1>Zen Match</h1>
        <div class="controls-row">
            <button class="new-game-btn" id="newGame">New Game</button>
            <div class="avg-display">Avg/Move: <span id="avgScore">0</span></div>
            <div class="gem-slider-container">
                <input type="range" id="gemSlider" min="2" max="10" value="5" class="gem-slider">
                <span class="gem-slider-value" id="gemSliderValue">5</span>
            </div>
        </div>
        <div class="floating-message" id="floatingMessage"></div>
        <div class="board" id="board"></div>
        <div class="stats-section">
            <div class="distribution-history" id="distHistory"></div>
            <canvas class="avg-sparkline" id="avgSparkline" width="200" height="24"></canvas>
            <div class="score-history" id="scoreHistory"></div>
        </div>
    </div>
    <div class="cascade-indicator" id="cascade"></div>
    <div class="combo-text" id="combo"></div>
    <div class="chain-text" id="chain"></div>
    <div class="shuffle-notice" id="shuffleNotice">Reshuffling...</div>

    <script>
        const ROWS = 8;
        const COLS = 8;

        // Gem count: from URL param or default 5
        const urlParams = new URLSearchParams(window.location.search);
        let GEM_TYPES = parseInt(urlParams.get('gems')) || 5;
        GEM_TYPES = Math.max(2, Math.min(10, GEM_TYPES)); // Clamp 2-10
        let pendingGemTypes = GEM_TYPES; // Slider value, applied on New Game

        // Special gem types
        const SPECIAL = {
            NONE: null,
            BOMB: 'bomb',      // 4-match: 3x3 explosion
            LINE: 'line',      // 5-match: clears row or column
            RAINBOW: 'rainbow' // 6+ match or L/T: clears all of one color
        };

        let board = [];
        let selected = null;
        let gamePoints = 0;  // Points earned this game (for avg calculation)
        let gameMoves = 0;   // Moves made this game
        let isProcessing = false;
        let abortCascade = false;  // Flag to interrupt cascades on New Game
        let cascadeCount = 0;
        let chainReactionCount = 0; // Track special->special chains
        let lastSwapPos = null;
        let pendingPoints = 0;  // Points accumulating during current cascade (for live display)

        // Stats tracking
        let distHistory = []; // Rolling history of gem distributions
        let scoreHistory = []; // Last N move scores
        let avgHistory = []; // Rolling history of game average convergence
        const MAX_HISTORY = 20;

        const boardEl = document.getElementById('board');
        const avgScoreEl = document.getElementById('avgScore');
        const scoreHistoryEl = document.getElementById('scoreHistory');
        const cascadeEl = document.getElementById('cascade');
        const comboEl = document.getElementById('combo');
        const chainEl = document.getElementById('chain');
        const shuffleNotice = document.getElementById('shuffleNotice');
        const distHistoryEl = document.getElementById('distHistory');
        const avgSparklineEl = document.getElementById('avgSparkline');
        const newGameBtn = document.getElementById('newGame');
        const gemSlider = document.getElementById('gemSlider');
        const gemSliderValue = document.getElementById('gemSliderValue');
        const floatingMessage = document.getElementById('floatingMessage');

        // Colors match CSS gem-N classes - ordered for adjacent contrast
        const gemColors = [
            '#7ec8e3', // 0: blue
            '#e07a5f', // 1: coral
            '#95d5b2', // 2: green
            '#f4d35e', // 3: yellow
            '#dda0dd', // 4: purple
            '#e8a87c', // 5: tan
            '#4ecdc4', // 6: teal
            '#ff9f43', // 7: orange
            '#5f6caf', // 8: navy
            '#ff6b9d', // 9: magenta
        ];

        // Locale-aware number formatting
        const compactFormatter = new Intl.NumberFormat(undefined, {
            notation: 'compact',
            maximumFractionDigits: 1
        });
        const standardFormatter = new Intl.NumberFormat(undefined);

        function formatNumber(n) {
            if (n >= 10000) return compactFormatter.format(n);
            return standardFormatter.format(n);
        }

        // Count gems by color
        function getGemDistribution() {
            const counts = new Array(GEM_TYPES).fill(0);
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) counts[board[r][c].type]++;
                }
            }
            return counts;
        }

        // Record move and update stats
        function recordMove(points) {
            distHistory.push(getGemDistribution());
            if (distHistory.length > MAX_HISTORY) distHistory.shift();

            if (points > 0) {
                // Track score history
                scoreHistory.unshift(points);
                if (scoreHistory.length > 8) scoreHistory.pop();

                // Update game average
                gamePoints += points;
                gameMoves++;
                const currentAvg = Math.round(gamePoints / gameMoves);
                avgScoreEl.textContent = formatNumber(currentAvg);

                // Track average convergence history
                avgHistory.push(currentAvg);
                if (avgHistory.length > MAX_HISTORY) avgHistory.shift();
            }
            renderStats();
        }

        // Live update stats during cascade (shows pending points accumulating)
        function liveUpdateStats() {
            if (pendingPoints > 0 && gameMoves >= 0) {
                // Show what avg would be if cascade ended now
                const projectedAvg = Math.round((gamePoints + pendingPoints) / (gameMoves + 1));
                avgScoreEl.textContent = formatNumber(projectedAvg);

                // Show pending points in score history (first position, highlighted)
                const liveHistory = [pendingPoints, ...scoreHistory.slice(0, 7)];
                scoreHistoryEl.innerHTML = liveHistory.map((s, i) =>
                    `<span${i === 0 ? ' class="live"' : ''}>+${formatNumber(s)}</span>`
                ).join('');

                // Live sparkline with projected point
                const liveAvgHistory = [...avgHistory, projectedAvg];
                renderSparkline(liveAvgHistory, true);
            }
            // Update distribution bar live
            distHistoryEl.innerHTML = [...distHistory, getGemDistribution()].slice(-MAX_HISTORY).map(dist => {
                const total = dist.reduce((a, b) => a + b, 0) || 1;
                return `<div class="dist-bar">${dist.map((count, i) =>
                    `<div class="dist-segment" style="height:${(count/total)*24}px;background:${gemColors[i]}"></div>`
                ).join('')}</div>`;
            }).join('');
        }

        // Render sparkline (extracted for reuse in live updates)
        function renderSparkline(history, isLive = false) {
            const canvas = avgSparklineEl;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            if (history.length > 0) {
                const min = Math.min(...history);
                const max = Math.max(...history);
                const range = max - min || 1;

                if (history.length > 1) {
                    ctx.strokeStyle = 'rgba(149, 213, 178, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    history.forEach((val, i) => {
                        const x = (i / (history.length - 1)) * w;
                        const y = h - ((val - min) / range) * h;
                        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                }

                // Highlight latest value with a dot (green if live, yellow if final)
                const lastVal = history[history.length - 1];
                const lastX = history.length > 1 ? w : w / 2;
                const lastY = h - ((lastVal - min) / range) * h;
                ctx.fillStyle = isLive ? '#95d5b2' : '#f4d35e';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Render stats displays
        function renderStats() {
            // Distribution history - stacked bars
            distHistoryEl.innerHTML = distHistory.map(dist => {
                const total = dist.reduce((a, b) => a + b, 0) || 1;
                return `<div class="dist-bar">${dist.map((count, i) =>
                    `<div class="dist-segment" style="height:${(count/total)*24}px;background:${gemColors[i]}"></div>`
                ).join('')}</div>`;
            }).join('');

            // Average convergence sparkline
            renderSparkline(avgHistory, false);

            // Score history - scrolling list of recent move scores
            scoreHistoryEl.innerHTML = scoreHistory.map(s => `<span>+${formatNumber(s)}</span>`).join('');
        }

        // New game handler
        newGameBtn.addEventListener('click', () => {
            if (isProcessing) {
                // Interrupt cascade and start new game
                abortCascade = true;
                // Small delay to let cascade abort, then start new game
                setTimeout(() => {
                    isProcessing = false;
                    startNewGame();
                }, 100);
                return;
            }
            startNewGame();
        });

        // Gem slider handler
        gemSlider.value = GEM_TYPES;
        gemSliderValue.textContent = GEM_TYPES;
        let floatingMessageTimeout;

        gemSlider.addEventListener('input', () => {
            const newValue = parseInt(gemSlider.value);
            gemSliderValue.textContent = newValue;
            pendingGemTypes = newValue;

            if (newValue !== GEM_TYPES) {
                showFloatingMessage('New Game to apply');
                // Auto-fade after 3 seconds
                clearTimeout(floatingMessageTimeout);
                floatingMessageTimeout = setTimeout(hideFloatingMessage, 3000);
            } else {
                hideFloatingMessage();
            }
        });

        function showFloatingMessage(text) {
            floatingMessage.textContent = text;
            floatingMessage.classList.add('visible');
        }

        function hideFloatingMessage() {
            floatingMessage.classList.remove('visible');
        }

        function startNewGame() {
            gamePoints = 0;
            gameMoves = 0;
            pendingPoints = 0;
            cascadeCount = 0;
            avgScoreEl.textContent = '0';
            distHistory = [];
            scoreHistory = [];
            avgHistory = [];
            // Hide cascade indicators
            cascadeEl.classList.remove('show');
            comboEl.classList.remove('show');
            chainEl.classList.remove('show');
            // Apply pending gem type change
            if (pendingGemTypes !== GEM_TYPES) {
                GEM_TYPES = pendingGemTypes;
                // Update URL without reload
                const newUrl = new URL(window.location);
                if (GEM_TYPES === 5) {
                    newUrl.searchParams.delete('gems');
                } else {
                    newUrl.searchParams.set('gems', GEM_TYPES);
                }
                history.replaceState({}, '', newUrl);
            }
            hideFloatingMessage();
            init();
        }

        function init() {
            board = [];
            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = { type: randomGem(r, c), special: SPECIAL.NONE, direction: null };
                }
            }
            let attempts = 0;
            while (findMatches().length > 0 && attempts < 100) {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        board[r][c] = { type: randomGem(r, c), special: SPECIAL.NONE, direction: null };
                    }
                }
                attempts++;
            }
            render();
            distHistory = [getGemDistribution()]; // Record initial state
            scoreHistory = [];
            renderStats();
        }

        function randomGem(r, c) {
            let type;
            let attempts = 0;
            do {
                type = Math.floor(Math.random() * GEM_TYPES);
                attempts++;
            } while (
                attempts < 50 &&
                ((c >= 2 && board[r][c-1]?.type === type && board[r][c-2]?.type === type) ||
                (r >= 2 && board[r-1]?.[c]?.type === type && board[r-2]?.[c]?.type === type))
            );
            return type;
        }

        function render() {
            boardEl.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    if (board[r][c]) {
                        const gem = document.createElement('div');
                        gem.className = `gem gem-${board[r][c].type}`;

                        // Apply special gem styling
                        if (board[r][c].special === SPECIAL.BOMB) {
                            gem.classList.add('special-bomb');
                        } else if (board[r][c].special === SPECIAL.LINE) {
                            gem.classList.add('special-line');
                            gem.classList.add(board[r][c].direction || 'horizontal');
                        } else if (board[r][c].special === SPECIAL.RAINBOW) {
                            gem.classList.add('special-rainbow');
                        }

                        if (selected && selected.r === r && selected.c === c) {
                            gem.classList.add('selected');
                        }

                        cell.appendChild(gem);
                    }

                    cell.addEventListener('click', () => handleClick(r, c));
                    boardEl.appendChild(cell);
                }
            }
        }

        function handleClick(r, c) {
            if (isProcessing || !board[r][c]) return;

            if (selected && selected.r === r && selected.c === c) {
                selected = null;
                render();
                return;
            }

            if (!selected) {
                selected = { r, c };
                render();
            } else {
                const dr = Math.abs(selected.r - r);
                const dc = Math.abs(selected.c - c);

                if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
                    // Validate both gems still exist before swapping
                    if (!board[selected.r][selected.c] || !board[r][c]) {
                        selected = null;
                        render();
                        return;
                    }
                    // Set processing flag immediately to prevent race conditions
                    isProcessing = true;
                    const selR = selected.r, selC = selected.c;
                    selected = null;
                    render();
                    trySwap(selR, selC, r, c);
                } else {
                    selected = { r, c };
                    render();
                    return;
                }
            }
        }

        async function trySwap(r1, c1, r2, c2) {
            isProcessing = true;
            lastSwapPos = { r1, c1, r2, c2 };
            let pointsEarned = 0;

            const gem1 = board[r1][c1];
            const gem2 = board[r2][c2];
            const gem1Special = gem1?.special;
            const gem2Special = gem2?.special;

            [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
            render();

            await sleep(200);

            // Check for special gem combos
            const gem1IsSpecial = gem1Special && gem1Special !== SPECIAL.NONE;
            const gem2IsSpecial = gem2Special && gem2Special !== SPECIAL.NONE;
            const bothAreSpecial = gem1IsSpecial && gem2IsSpecial;

            if (bothAreSpecial) {
                // Two special gems - ALWAYS allow swap and trigger combo regardless of color
                const specials = [gem1Special, gem2Special];
                const isRainbowCombo = specials.includes(SPECIAL.RAINBOW);
                const isBombCombo = specials.every(s => s === SPECIAL.BOMB);
                const isLineCombo = specials.every(s => s === SPECIAL.LINE);
                const isBombLineCombo = specials.includes(SPECIAL.BOMB) && specials.includes(SPECIAL.LINE);

                cascadeCount = 1;
                chainReactionCount = 0;
                const toRemove = new Set();
                const animationClasses = new Map();
                let points = 0;

                // Center position for combo effects
                const centerR = Math.floor((r1 + r2) / 2);
                const centerC = Math.floor((c1 + c2) / 2);

                if (isRainbowCombo) {
                    // Rainbow combos
                    const gem1IsRainbow = gem1Special === SPECIAL.RAINBOW;
                    const gem2IsRainbow = gem2Special === SPECIAL.RAINBOW;
                    const otherSpecial = gem1IsRainbow ? gem2Special : gem1Special;

                    if (gem1IsRainbow && gem2IsRainbow) {
                        // Two rainbows: clear entire board
                        for (let r = 0; r < ROWS; r++) {
                            for (let c = 0; c < COLS; c++) {
                                if (board[r][c]) {
                                    toRemove.add(`${r},${c}`);
                                    animationClasses.set(`${r},${c}`, 'rainbow-cleared');
                                }
                            }
                        }
                        points = 5000;
                    } else if (otherSpecial === SPECIAL.BOMB) {
                        // Rainbow + Bomb: every gem of that color EXPLODES
                        const targetType = gem1IsRainbow ? gem2.type : gem1.type;
                        const colorPositions = [];

                        // Find all gems of target color
                        for (let r = 0; r < ROWS; r++) {
                            for (let c = 0; c < COLS; c++) {
                                if (board[r][c]?.type === targetType) {
                                    colorPositions.push({ r, c });
                                }
                            }
                        }

                        // Each one explodes in 3x3
                        for (const pos of colorPositions) {
                            showExplosionEffect(pos.r, pos.c);
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dc = -1; dc <= 1; dc++) {
                                    const nr = pos.r + dr;
                                    const nc = pos.c + dc;
                                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc]) {
                                        toRemove.add(`${nr},${nc}`);
                                        animationClasses.set(`${nr},${nc}`, 'exploding');
                                    }
                                }
                            }
                        }

                        // Also remove the rainbow
                        const rainbowPos = gem1IsRainbow ? `${r2},${c2}` : `${r1},${c1}`;
                        toRemove.add(rainbowPos);
                        animationClasses.set(rainbowPos, 'rainbow-cleared');
                        points = 2000 + toRemove.size * 20;
                    } else if (otherSpecial === SPECIAL.LINE) {
                        // Rainbow + Line: every gem of that color triggers line clear
                        const targetType = gem1IsRainbow ? gem2.type : gem1.type;
                        const lineGem = gem1IsRainbow ? gem2 : gem1;
                        const isVertical = lineGem.direction === 'vertical';

                        // Find all gems of target color
                        for (let r = 0; r < ROWS; r++) {
                            for (let c = 0; c < COLS; c++) {
                                if (board[r][c]?.type === targetType) {
                                    // Clear row or column based on line direction
                                    if (isVertical) {
                                        for (let i = 0; i < ROWS; i++) {
                                            if (board[i][c]) {
                                                toRemove.add(`${i},${c}`);
                                                animationClasses.set(`${i},${c}`, 'line-cleared');
                                            }
                                        }
                                        showLineEffect(null, c, 'vertical');
                                    } else {
                                        for (let i = 0; i < COLS; i++) {
                                            if (board[r][i]) {
                                                toRemove.add(`${r},${i}`);
                                                animationClasses.set(`${r},${i}`, 'line-cleared');
                                            }
                                        }
                                        showLineEffect(r, null, 'horizontal');
                                    }
                                }
                            }
                        }

                        // Also remove the rainbow
                        const rainbowPos = gem1IsRainbow ? `${r2},${c2}` : `${r1},${c1}`;
                        toRemove.add(rainbowPos);
                        animationClasses.set(rainbowPos, 'rainbow-cleared');
                        points = 2500 + toRemove.size * 20;
                    } else {
                        // Rainbow + regular gem: clear all of that color
                        const targetType = gem1IsRainbow ? gem2.type : gem1.type;
                        for (let r = 0; r < ROWS; r++) {
                            for (let c = 0; c < COLS; c++) {
                                if (board[r][c]?.type === targetType) {
                                    toRemove.add(`${r},${c}`);
                                    animationClasses.set(`${r},${c}`, 'rainbow-cleared');
                                }
                            }
                        }
                        const rainbowPos = gem1IsRainbow ? `${r2},${c2}` : `${r1},${c1}`;
                        toRemove.add(rainbowPos);
                        animationClasses.set(rainbowPos, 'rainbow-cleared');
                        points = 500 + toRemove.size * 10;
                    }
                } else if (isBombCombo) {
                    // Bomb + Bomb: 5x5 explosion
                    for (let dr = -2; dr <= 2; dr++) {
                        for (let dc = -2; dc <= 2; dc++) {
                            const nr = r1 + dr;
                            const nc = c1 + dc;
                            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc]) {
                                toRemove.add(`${nr},${nc}`);
                                animationClasses.set(`${nr},${nc}`, 'exploding');
                            }
                        }
                    }
                    showExplosionEffect(r1, c1);
                    points = 1000 + toRemove.size * 15;
                } else if (isLineCombo) {
                    // Line + Line: cross clear (row + column)
                    for (let i = 0; i < COLS; i++) {
                        if (board[r1][i]) {
                            toRemove.add(`${r1},${i}`);
                            animationClasses.set(`${r1},${i}`, 'line-cleared');
                        }
                    }
                    for (let i = 0; i < ROWS; i++) {
                        if (board[i][c1]) {
                            toRemove.add(`${i},${c1}`);
                            animationClasses.set(`${i},${c1}`, 'line-cleared');
                        }
                    }
                    showLineEffect(r1, null, 'horizontal');
                    showLineEffect(null, c1, 'vertical');
                    points = 800 + toRemove.size * 12;
                } else if (isBombLineCombo) {
                    // Bomb + Line: clear 3 rows OR 3 columns (based on line direction)
                    const lineGem = gem1Special === SPECIAL.LINE ? gem1 : gem2;
                    const linePos = gem1Special === SPECIAL.LINE ? { r: r2, c: c2 } : { r: r1, c: c1 };

                    if (lineGem.direction === 'vertical') {
                        // Clear 3 columns
                        for (let dc = -1; dc <= 1; dc++) {
                            const col = linePos.c + dc;
                            if (col >= 0 && col < COLS) {
                                for (let i = 0; i < ROWS; i++) {
                                    if (board[i][col]) {
                                        toRemove.add(`${i},${col}`);
                                        animationClasses.set(`${i},${col}`, 'line-cleared');
                                    }
                                }
                                showLineEffect(null, col, 'vertical');
                            }
                        }
                    } else {
                        // Clear 3 rows
                        for (let dr = -1; dr <= 1; dr++) {
                            const row = linePos.r + dr;
                            if (row >= 0 && row < ROWS) {
                                for (let i = 0; i < COLS; i++) {
                                    if (board[row][i]) {
                                        toRemove.add(`${row},${i}`);
                                        animationClasses.set(`${row},${i}`, 'line-cleared');
                                    }
                                }
                                showLineEffect(row, null, 'horizontal');
                            }
                        }
                    }
                    points = 1200 + toRemove.size * 15;
                }

                // Recursively activate special gems caught in combo blast radius
                const { bonusPoints, chainCount } = await activateSpecialsInRemovalSet(toRemove, animationClasses);
                chainReactionCount += chainCount;
                points += bonusPoints;

                // Two specials always trigger - guaranteed to have items in toRemove
                pointsEarned += points;
                showScorePopup(points, true, chainReactionCount > 0);

                // Animate removal
                for (const key of toRemove) {
                    const [r, c] = key.split(',').map(Number);
                    const cell = boardEl.children[r * COLS + c];
                    const gemEl = cell?.querySelector('.gem');
                    if (gemEl) {
                        gemEl.classList.add(animationClasses.get(key) || 'matched');
                    }
                }

                await sleep(400);

                // Remove gems
                for (const key of toRemove) {
                    const [r, c] = key.split(',').map(Number);
                    board[r][c] = null;
                }

                render();
                await dropGems();
                await fillGems();

                // Continue with any cascading matches
                const matches = findMatches();
                if (matches.length > 0) {
                    pointsEarned += await processMatches();
                }

                if (!hasValidMoves()) {
                    await shuffleBoard();
                }
            } else if (gem1Special === SPECIAL.RAINBOW || gem2Special === SPECIAL.RAINBOW) {
                // Rainbow + regular gem: ALWAYS activates - clear all gems of that color
                const gem1IsRainbow = gem1Special === SPECIAL.RAINBOW;
                const targetType = gem1IsRainbow ? gem2.type : gem1.type;
                // After the swap, rainbow moved to the OTHER position
                const rainbowPos = gem1IsRainbow ? { r: r2, c: c2 } : { r: r1, c: c1 };

                cascadeCount = 1;
                chainReactionCount = 0;
                const toRemove = new Set();
                const animationClasses = new Map();

                // Find and mark all gems of target color
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c]?.type === targetType) {
                            toRemove.add(`${r},${c}`);
                            animationClasses.set(`${r},${c}`, 'rainbow-cleared');
                        }
                    }
                }

                // Also remove the rainbow itself
                toRemove.add(`${rainbowPos.r},${rainbowPos.c}`);
                animationClasses.set(`${rainbowPos.r},${rainbowPos.c}`, 'rainbow-cleared');

                // Recursively activate special gems caught in the rainbow clear
                const { bonusPoints, chainCount } = await activateSpecialsInRemovalSet(toRemove, animationClasses);
                chainReactionCount = chainCount;

                const points = 500 + toRemove.size * 10 + bonusPoints;

                // Apply animation classes
                for (const [key, className] of animationClasses) {
                    const [r, c] = key.split(',').map(Number);
                    const cell = boardEl.children[r * COLS + c];
                    const gemEl = cell?.querySelector('.gem');
                    if (gemEl) gemEl.classList.add(className);
                }

                await sleep(400); // Unified timing for all removal animations

                // Remove gems
                for (const key of toRemove) {
                    const [r, c] = key.split(',').map(Number);
                    board[r][c] = null;
                }

                pointsEarned += points;
                showScorePopup(points, true, chainReactionCount > 0);

                render();
                await dropGems();
                await fillGems();

                // Continue with any cascading matches
                const matches = findMatches();
                if (matches.length > 0) {
                    pointsEarned += await processMatches();
                }

                if (!hasValidMoves()) {
                    await shuffleBoard();
                }
            } else if (gem1IsSpecial || gem2IsSpecial) {
                // One special (bomb/line) + one regular: only valid if creates a match
                const matches = findMatches();
                if (matches.length > 0) {
                    cascadeCount = 0;
                    chainReactionCount = 0;
                    pointsEarned += await processMatches();

                    if (!hasValidMoves()) {
                        await shuffleBoard();
                    }
                } else {
                    // No match - invalid swap, revert
                    const cell1 = boardEl.children[r1 * COLS + c1];
                    const cell2 = boardEl.children[r2 * COLS + c2];
                    const gemEl1 = cell1?.querySelector('.gem');
                    const gemEl2 = cell2?.querySelector('.gem');

                    if (gemEl1) gemEl1.classList.add('invalid');
                    if (gemEl2) gemEl2.classList.add('invalid');

                    await sleep(400);

                    [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
                    render();
                }
            } else {
                // Normal swap - check for matches
                const matches = findMatches();
                if (matches.length === 0) {
                    const cell1 = boardEl.children[r1 * COLS + c1];
                    const cell2 = boardEl.children[r2 * COLS + c2];
                    const gemEl1 = cell1?.querySelector('.gem');
                    const gemEl2 = cell2?.querySelector('.gem');

                    if (gemEl1) gemEl1.classList.add('invalid');
                    if (gemEl2) gemEl2.classList.add('invalid');

                    await sleep(400);

                    [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
                    render();
                } else {
                    cascadeCount = 0;
                    chainReactionCount = 0;
                    pointsEarned += await processMatches();

                    if (!hasValidMoves()) {
                        await shuffleBoard();
                    }
                }
            }

            isProcessing = false;
            lastSwapPos = null; // Reset so cascades don't inherit old swap position
            recordMove(pointsEarned); // Track move stats
        }

        function findMatches() {
            const matchedCells = new Map();

            // Find horizontal matches
            for (let r = 0; r < ROWS; r++) {
                let c = 0;
                while (c < COLS) {
                    if (!board[r][c]) { c++; continue; }

                    // Build a run of matching gems
                    const type = board[r][c].type;
                    let endC = c + 1;
                    while (endC < COLS && board[r][endC]?.type === type) {
                        endC++;
                    }

                    const len = endC - c;
                    if (len >= 3) {

                        for (let i = c; i < endC; i++) {
                            const key = `${r},${i}`;
                            if (!matchedCells.has(key)) {
                                matchedCells.set(key, { r, c: i, type, matchLen: len, direction: 'horizontal' });
                            } else {
                                matchedCells.get(key).matchLen = Math.max(matchedCells.get(key).matchLen, len);
                                matchedCells.get(key).isComplex = true;
                            }
                        }
                    }
                    c = endC;
                }
            }

            // Find vertical matches
            for (let c = 0; c < COLS; c++) {
                let r = 0;
                while (r < ROWS) {
                    if (!board[r][c]) { r++; continue; }

                    // Build a run of matching gems
                    const type = board[r][c].type;
                    let endR = r + 1;
                    while (endR < ROWS && board[endR][c]?.type === type) {
                        endR++;
                    }

                    const len = endR - r;
                    if (len >= 3) {

                        for (let i = r; i < endR; i++) {
                            const key = `${i},${c}`;
                            if (!matchedCells.has(key)) {
                                matchedCells.set(key, { r: i, c, type, matchLen: len, direction: 'vertical' });
                            } else {
                                const existing = matchedCells.get(key);
                                existing.matchLen += len;
                                existing.isComplex = true;
                            }
                        }
                    }
                    r = endR;
                }
            }

            if (matchedCells.size === 0) return [];

            // Group connected matches
            const matches = [];
            const visited = new Set();

            for (const [key, data] of matchedCells) {
                if (visited.has(key)) continue;

                const match = [];
                const queue = [key];
                let hasComplex = false;
                let hDir = false, vDir = false;

                while (queue.length > 0) {
                    const current = queue.shift();
                    if (visited.has(current)) continue;
                    visited.add(current);

                    const cellData = matchedCells.get(current);
                    if (!cellData) continue;

                    match.push({ r: cellData.r, c: cellData.c });
                    if (cellData.isComplex) hasComplex = true;
                    if (cellData.direction === 'horizontal') hDir = true;
                    if (cellData.direction === 'vertical') vDir = true;

                    const [cr, cc] = current.split(',').map(Number);
                    const neighbors = [
                        `${cr-1},${cc}`, `${cr+1},${cc}`,
                        `${cr},${cc-1}`, `${cr},${cc+1}`
                    ];

                    for (const neighbor of neighbors) {
                        if (matchedCells.has(neighbor) && !visited.has(neighbor)) {
                            const neighborData = matchedCells.get(neighbor);
                            if (neighborData.type === cellData.type) {
                                queue.push(neighbor);
                            }
                        }
                    }
                }

                match.effectiveLen = hasComplex ? match.length : data.matchLen;
                match.isComplex = hasComplex;
                match.direction = hDir && vDir ? 'both' : (hDir ? 'horizontal' : 'vertical');
                match.type = data.type;
                matches.push(match);
            }

            return matches;
        }

        // Recursively activate all special gems within a removal set
        // Returns { bonusPoints, chainCount } for scoring
        async function activateSpecialsInRemovalSet(toRemove, animationClasses) {
            let bonusPoints = 0;
            let chainCount = 0;
            let newSpecialsFound = true;
            let iterations = 0;
            const maxIterations = 20;

            while (newSpecialsFound && iterations < maxIterations) {
                newSpecialsFound = false;
                iterations++;

                const currentToRemove = new Set(toRemove);

                for (const key of currentToRemove) {
                    const [r, c] = key.split(',').map(Number);
                    const gem = board[r]?.[c];
                    if (!gem || !gem.special) continue;
                    if (gem._processed) continue;
                    gem._processed = true;

                    if (gem.special === SPECIAL.BOMB) {
                        chainCount++;
                        showChainReaction(chainCount);

                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                                    const newKey = `${nr},${nc}`;
                                    if (!toRemove.has(newKey)) {
                                        toRemove.add(newKey);
                                        animationClasses.set(newKey, 'exploding');
                                        newSpecialsFound = true;
                                    }
                                }
                            }
                        }
                        animationClasses.set(key, 'exploding');
                        bonusPoints += 150;
                        showExplosionEffect(r, c);

                    } else if (gem.special === SPECIAL.LINE) {
                        chainCount++;
                        showChainReaction(chainCount);

                        const dir = gem.direction || 'horizontal';

                        if (dir === 'horizontal' || dir === 'cross') {
                            for (let i = 0; i < COLS; i++) {
                                const newKey = `${r},${i}`;
                                if (!toRemove.has(newKey)) {
                                    toRemove.add(newKey);
                                    animationClasses.set(newKey, 'line-cleared');
                                    newSpecialsFound = true;
                                }
                            }
                            showLineEffect(r, null, 'horizontal');
                        }

                        if (dir === 'vertical' || dir === 'cross') {
                            for (let i = 0; i < ROWS; i++) {
                                const newKey = `${i},${c}`;
                                if (!toRemove.has(newKey)) {
                                    toRemove.add(newKey);
                                    animationClasses.set(newKey, 'line-cleared');
                                    newSpecialsFound = true;
                                }
                            }
                            showLineEffect(null, c, 'vertical');
                        }

                        animationClasses.set(key, 'line-cleared');
                        bonusPoints += 200;

                    } else if (gem.special === SPECIAL.RAINBOW) {
                        chainCount++;
                        showChainReaction(chainCount);

                        // Use the rainbow's stored color (consistent with its visual center)
                        const targetType = gem.type;

                        for (let i = 0; i < ROWS; i++) {
                            for (let j = 0; j < COLS; j++) {
                                if (board[i][j]?.type === targetType) {
                                    const newKey = `${i},${j}`;
                                    if (!toRemove.has(newKey)) {
                                        toRemove.add(newKey);
                                        animationClasses.set(newKey, 'rainbow-cleared');
                                        newSpecialsFound = true;
                                    }
                                }
                            }
                        }
                        animationClasses.set(key, 'rainbow-cleared');
                        bonusPoints += 500;
                    }
                }

                if (newSpecialsFound) {
                    await sleep(150);
                }
            }

            // Clear processed flags
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        delete board[r][c]._processed;
                    }
                }
            }

            return { bonusPoints, chainCount };
        }

        async function processMatches() {
            let matches = findMatches();
            let totalPoints = 0;
            pendingPoints = 0;  // Reset for live display

            while (matches.length > 0) {
                // Check for abort (New Game pressed)
                if (abortCascade) {
                    abortCascade = false;
                    pendingPoints = 0;
                    return 0;
                }

                cascadeCount++;
                showCascade(cascadeCount);
                showCombo(cascadeCount);

                const toRemove = new Set();
                const specials = [];
                let matchBonus = 0;
                const animationClasses = new Map(); // Track which animation each cell gets

                for (const match of matches) {
                    const len = match.effectiveLen || match.length;
                    const type = match.type;

                    // Determine special gem creation based on match size
                    if (match.isComplex || len >= 6) {
                        // L/T shape or 6+ match: Rainbow gem
                        const pos = findBestSpecialPosition(match);
                        specials.push({ pos, type, special: SPECIAL.RAINBOW });
                        matchBonus += 200;
                    } else if (len === 5) {
                        // 5-match: Line clear gem
                        const pos = findBestSpecialPosition(match);
                        const clearDir = match.direction === 'horizontal' ? 'vertical' : 'horizontal';
                        specials.push({ pos, type, special: SPECIAL.LINE, direction: clearDir });
                        matchBonus += 100;
                    } else if (len === 4) {
                        // 4-match: Bomb gem (3x3 explosion)
                        const pos = findBestSpecialPosition(match);
                        specials.push({ pos, type, special: SPECIAL.BOMB });
                        matchBonus += 50;
                    }

                    if (len > 3) {
                        matchBonus += Math.pow(len - 3, 2) * 20;
                    }

                    for (const pos of match) {
                        toRemove.add(`${pos.r},${pos.c}`);
                    }
                }

                // Recursively activate special gems caught in matches
                const { bonusPoints, chainCount } = await activateSpecialsInRemovalSet(toRemove, animationClasses);
                matchBonus += bonusPoints;
                chainReactionCount = chainCount;

                // Calculate points
                const basePoints = toRemove.size * 10;
                const cascadeMultiplier = cascadeCount;
                const chainMultiplier = 1 + (chainReactionCount * 0.5);
                const points = Math.floor((basePoints + matchBonus) * cascadeMultiplier * chainMultiplier);
                totalPoints += points;
                pendingPoints = totalPoints;  // Update for live display

                showScorePopup(points, matchBonus > 50, chainReactionCount > 0);
                liveUpdateStats();  // Live update avg/move and score history

                // Animate removal with appropriate animations
                for (const key of toRemove) {
                    const [r, c] = key.split(',').map(Number);
                    const cell = boardEl.children[r * COLS + c];
                    const gem = cell?.querySelector('.gem');
                    if (gem) {
                        const animClass = animationClasses.get(key) || 'matched';
                        gem.classList.add(animClass);
                    }
                }

                await sleep(400);

                // Remove gems
                for (const key of toRemove) {
                    const [r, c] = key.split(',').map(Number);
                    board[r][c] = null;
                }

                // Create special gems with priority resolution (RAINBOW > LINE > BOMB)
                const specialPriority = { [SPECIAL.RAINBOW]: 3, [SPECIAL.LINE]: 2, [SPECIAL.BOMB]: 1 };
                specials.sort((a, b) => specialPriority[b.special] - specialPriority[a.special]);

                const usedPositions = new Set();
                for (const sp of specials) {
                    const posKey = `${sp.pos.r},${sp.pos.c}`;

                    // Skip if position already used by higher-priority special
                    if (usedPositions.has(posKey)) {
                        continue;
                    }

                    if (!board[sp.pos.r][sp.pos.c]) {
                        board[sp.pos.r][sp.pos.c] = {
                            type: sp.type,
                            special: sp.special,
                            direction: sp.direction || null
                        };
                        usedPositions.add(posKey);
                    } else {
                        console.warn(`Special gem creation failed: position (${sp.pos.r},${sp.pos.c}) not empty`);
                    }
                }

                render();
                await sleep(100);

                await dropGems();
                await fillGems();

                // Reset chain count for next cascade
                chainReactionCount = 0;

                matches = findMatches();
            }

            setTimeout(() => {
                cascadeEl.classList.remove('show');
                comboEl.classList.remove('show');
                chainEl.classList.remove('show');
            }, 500);

            return totalPoints;
        }

        function showExplosionEffect(r, c) {
            const cell = boardEl.children[r * COLS + c];
            if (!cell) return;

            const rect = cell.getBoundingClientRect();
            const boardRect = boardEl.getBoundingClientRect();

            const effect = document.createElement('div');
            effect.className = 'explosion-effect';
            effect.style.left = (rect.left - boardRect.left + rect.width/2) + 'px';
            effect.style.top = (rect.top - boardRect.top + rect.height/2) + 'px';
            boardEl.appendChild(effect);

            setTimeout(() => effect.remove(), 500);
        }

        function showLineEffect(row, col, direction) {
            const effect = document.createElement('div');
            effect.className = 'line-effect ' + direction;

            if (direction === 'horizontal' && row !== null) {
                const cell = boardEl.children[row * COLS];
                if (cell) {
                    const rect = cell.getBoundingClientRect();
                    const boardRect = boardEl.getBoundingClientRect();
                    effect.style.top = (rect.top - boardRect.top) + 'px';
                }
            } else if (direction === 'vertical' && col !== null) {
                const cell = boardEl.children[col];
                if (cell) {
                    const rect = cell.getBoundingClientRect();
                    const boardRect = boardEl.getBoundingClientRect();
                    effect.style.left = (rect.left - boardRect.left) + 'px';
                }
            }

            boardEl.appendChild(effect);
            setTimeout(() => effect.remove(), 400);
        }

        function showChainReaction(count) {
            if (count > 0) {
                chainEl.textContent = 'Chain x' + count + '!';
                chainEl.classList.add('show');
            }
        }

        function findBestSpecialPosition(match) {
            if (lastSwapPos) {
                for (const pos of match) {
                    if ((pos.r === lastSwapPos.r1 && pos.c === lastSwapPos.c1) ||
                        (pos.r === lastSwapPos.r2 && pos.c === lastSwapPos.c2)) {
                        return pos;
                    }
                }
            }
            return match[Math.floor(match.length / 2)];
        }

        async function dropGems() {
            let dropped = false;

            for (let c = 0; c < COLS; c++) {
                let writePos = ROWS - 1;
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r][c]) {
                        if (writePos !== r) {
                            board[writePos][c] = board[r][c];
                            board[r][c] = null;
                            dropped = true;
                        }
                        writePos--;
                    }
                }
            }

            if (dropped) {
                render();
                await sleep(250);
            }
        }

        async function fillGems() {
            let filled = false;

            for (let c = 0; c < COLS; c++) {
                for (let r = 0; r < ROWS; r++) {
                    if (!board[r][c]) {
                        board[r][c] = {
                            type: Math.floor(Math.random() * GEM_TYPES),
                            special: SPECIAL.NONE,
                            direction: null
                        };
                        filled = true;
                    }
                }
            }

            if (filled) {
                render();
                await sleep(200);
            }
        }

        function hasValidMoves() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (c < COLS - 1 && board[r][c] && board[r][c+1]) {
                        [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                        const hasMatch = findMatches().length > 0;
                        [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                        if (hasMatch) return true;
                    }
                    if (r < ROWS - 1 && board[r][c] && board[r+1][c]) {
                        [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                        const hasMatch = findMatches().length > 0;
                        [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                        if (hasMatch) return true;
                    }
                }
            }
            return false;
        }

        function findValidMove() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (c < COLS - 1 && board[r][c] && board[r][c+1]) {
                        [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                        const hasMatch = findMatches().length > 0;
                        [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                        if (hasMatch) return { r1: r, c1: c, r2: r, c2: c + 1 };
                    }
                    if (r < ROWS - 1 && board[r][c] && board[r+1][c]) {
                        [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                        const hasMatch = findMatches().length > 0;
                        [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                        if (hasMatch) return { r1: r, c1: c, r2: r + 1, c2: c };
                    }
                }
            }
            return null;
        }

        async function shuffleBoard(attempts = 0) {
            const MAX_SHUFFLE_ATTEMPTS = 10;

            shuffleNotice.classList.add('show');
            await sleep(500);

            const gems = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        gems.push(board[r][c]);
                    }
                }
            }

            for (let i = gems.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gems[i], gems[j]] = [gems[j], gems[i]];
            }

            let idx = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = gems[idx++];
                }
            }

            render();
            await sleep(500);

            if (findMatches().length > 0) {
                await processMatches();
            }

            if (!hasValidMoves() && attempts < MAX_SHUFFLE_ATTEMPTS) {
                await shuffleBoard(attempts + 1);
            } else if (!hasValidMoves()) {
                // After max attempts, regenerate board completely
                init();
            }

            shuffleNotice.classList.remove('show');
        }

        function showCascade(count) {
            if (count > 1) {
                cascadeEl.textContent = count + 'x Cascade!';
                cascadeEl.classList.add('show');
            }
        }

        function showCombo(count) {
            const texts = [
                null,
                null,
                { text: 'Good!', class: 'good' },
                { text: 'Great!', class: 'great' },
                { text: 'Amazing!', class: 'amazing' },
                { text: 'Incredible!', class: 'incredible' }
            ];

            const combo = texts[Math.min(count, texts.length - 1)];
            if (combo) {
                comboEl.textContent = combo.text;
                comboEl.className = 'combo-text show ' + combo.class;
            }
        }

        function showScorePopup(points, isBonus = false, isChain = false) {
            const popup = document.createElement('div');
            popup.className = 'score-popup' + (isChain ? ' chain' : (isBonus ? ' bonus' : ''));
            popup.textContent = '+' + points;
            popup.style.left = '50%';
            popup.style.top = '45%';
            popup.style.transform = 'translateX(-50%)';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        init();
    </script>
</body>
</html>
